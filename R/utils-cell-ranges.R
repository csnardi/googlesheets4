A1_char_class <- "[a-zA-Z0-9:$]"
compound_rx <- glue("(?<sheet>^.+)!(?<range>{A1_char_class}+$)")
letter_part <- "[$]?[A-Za-z]{1,3}"
number_part <- "[$]?[0-9]{1,7}"
A1_rx <- glue("^{letter_part}{number_part}$|^{letter_part}$|^{number_part}$")
A1_decomp <- glue("(?<column>{letter_part})?(?<row>{number_part})?")

## range_spec is an "internal-use only" S3 class ----
new_range_spec <- function(...) {
  l <- list(...)
  structure(
    list(
      sheet_name  = l$sheet_name  %||% NULL,
      named_range = l$named_range %||% NULL,
      A1_range    = l$A1_range    %||% NULL,
      api_range   = l$api_range   %||% NULL,
      shim        = FALSE,
      cell_limits = l$cell_limits %||% NULL
    ),
    .input = l$.input,
    class = "range_spec"
  )
}

as_range_spec <- function(x, ...) {
  UseMethod("as_range_spec")
}

as_range_spec.default <- function(x, ...) {
  bad_class <- glue_collapse(class(x), sep = "/")
  stop_glue(
    "{bt('range')} must be NULL, a string, or a cell_limits object.\n",
    "Don't know how to make a range for the Sheets API from an object of class <{bad_class}>"
  )
}

# anticipated inputs to the character method for x (= range)
# **** means "doesn't matter, never consulted"
#
# sheet   range         skip
# --------------------------------------
# ****    Sheet1!A1:B2  ****
# ****    Named_range   ****
# ****    Sheet1        i     weird, but I guess we roll with it (re-dispatch)
#         A1:B2         ****
# Sheet1  A1:B2         ****
# 3       A1:B2         ****
as_range_spec.character <- function(x,
                                    ...,
                                    sheet = NULL,
                                    skip = 0,
                                    sheet_names = NULL,
                                    nr_names = NULL) {
  check_length_one(x)

  out <- new_range_spec(
    .input = list(
      sheet = sheet, range = x, skip = skip,
      sheet_names = sheet_names, nr_names = nr_names
    )
  )

  m <- rematch2::re_match(x, compound_rx)

  # range looks like: Sheet1!A1:B2
  if (notNA(m[[".match"]])) {
    out$sheet_name <- resolve_sheet(m$sheet, sheet_names)
    out$A1_range   <- m$range
    out$api_range  <- qualified_A1(out$sheet_name, out$A1_range)
    out$shim       <- TRUE
    return(out)
  }

  # check if range matches a named range
  m <- match(x, nr_names)
  if (notNA(m)) {
    out$api_range <- out$named_range <- x
    return(out)
  }

  # check if range matches a sheet name
  # API docs: "When a named range conflicts with a sheet's name, the named range
  # is preferred."
  m <- match(x, sheet_names)
  if (notNA(m)) {
    # Re-dispatch. Match already established, so no need to pass sheet names.
    return(as_range_spec(x = NULL, sheet = x, skip = skip))
  }

  # range must be in A1 notation
  m <- grepl(A1_rx, strsplit(x, split = ":")[[1]])
  if (!all(m)) {
    stop_glue(
      "{bt('range')} doesn't appear to be a range in A1 notation, a named ",
      "range, or a sheet name:\n",
      "  * {sq(x)}"
    )
  }
  out$A1_range <- x
  if (!is.null(sheet)) {
    out$sheet_name <- resolve_sheet(sheet, sheet_names)
  }
  out$api_range <- qualified_A1(out$sheet_name, out$A1_range)
  out$shim <- TRUE
  out
}

# anticipated inputs to the NULL method for x (= range)
#
# sheet       skip
# --------------------------------------
#             0     This is what "nothing" looks like. Send nothing.
# Sheet1 / 2  0     Send sheet name.
#             >0    Express skip request in cell_limits object and re-dispatch.
# Sheet1 / 2  >0    <same as previous>
as_range_spec.NULL <- function(x,
                               ...,
                               sheet = NULL,
                               skip = 0,
                               sheet_names = NULL) {
  out <- new_range_spec(
    .input = list(
      sheet = sheet, range = x, skip = skip,
      sheet_names = sheet_names
    )
  )

  if (is.null(sheet)) {
    if (skip < 1) {
      return(out)
    } else {
      return(
        as_range_spec(
          x = cell_rows(c(skip + 1, NA)),
          sheet = sheet, sheet_names = sheet_names, shim = FALSE
        )
      )
    }
  }

  out$sheet_name <- resolve_sheet(sheet, sheet_names)
  out$api_range <- qualified_A1(out$sheet_name)
  out
}

# anticipated inputs to the cell_limits method for x (= range)
#
# sheet       range
# --------------------------------------
#             cell_limits   Send A1 representation of cell_limits. Let the API
#                           figure out the sheet. API docs imply it will be the
#                           "first visible sheet".
# Sheet1 / 2  cell_limits   Resolve sheet name, make A1 range, send combined
#                           result.
as_range_spec.cell_limits <- function(x,
                                      ...,
                                      shim = TRUE,
                                      sheet = NULL,
                                      sheet_names = NULL) {
  out <- new_range_spec(
    .input = list(
      sheet = sheet, range = x, sheet_names = sheet_names, shim = shim
    )
  )
  out$cell_limits <- resolve_limits(x)
  out$A1_range <- as_sheets_range(out$cell_limits)
  if (!is.null(sheet)) {
    out$sheet_name <- resolve_sheet(sheet, sheet_names)
  }
  out$shim <- shim
  out$api_range <- qualified_A1(out$sheet_name, out$A1_range)
  out
}

resolve_sheet <- function(sheet = NULL, sheet_names = NULL) {
  if (is.null(sheet)) {
    return()
  }
  check_sheet(sheet)

  if (is.character(sheet)) {
    sheet <- sq_unescape(sheet)
    if (length(sheet_names) > 0) {
      m <- match(sheet, sheet_names)
      if (is.na(m)) {
        stop_glue("No sheet found with this name: {sq(sheet)}")
      }
    }
    return(sheet)
  }

  if (length(sheet_names) < 1) {
    stop_glue("Sheet specified by number, but no sheet names provided for lookup.")
  }
  m <- as.integer(sheet)
  if (!(m %in% seq_along(sheet_names))) {
    stop_glue(
      "There are {length(sheet_names)} sheet names:\n",
      "  * Requested sheet number is out-of-bounds: {m}"
    )
  }
  sheet_names[[m]]
}

check_sheet <- function(sheet = NULL) {
  if (is.null(sheet)) {
    return()
  }
  check_length_one(sheet)
  if (!is.character(sheet) && !is.numeric(sheet)) {
    stop_glue(
      "{bt('sheet')} must be either character (sheet name) or ",
      "numeric (sheet number):\n",
      "  * {bt('sheet')} has class {glue_collapse(class(sheet), sep = '/')}"
    )
  }
  return(sheet)
}

qualified_A1 <- function(sheet_name = NULL, A1_range = NULL) {
  # API docs: "For simplicity, it is safe to always surround the sheet name
  # with single quotes."
  paste0(c(sq_escape(sheet_name), A1_range), collapse = "!")
}

# shim around cellranger::as.range()
# I'm not sure if this is permanent or not?
# currently cellranger::as.range() does not tolerate any NAs
# but some valid Sheets ranges imply NAs in the cell limits
# hence, this function must exist for now
as_sheets_range <- function(x) {
  stopifnot(inherits(x, what = "cell_limits"))
  # TODO: we don't show people providing sheet name via cell_limits
  #       so I proceed as if sheet is always specified elsewhere
  x$sheet <- NA_character_
  limits <- x[c("ul", "lr")]

  ## "case numbers" refer to output produced by:
  # tidyr::crossing(
  #   start_row = c(NA, "start_row"), start_col = c(NA, "start_col"),
  #   end_row = c(NA, "end_row"), end_col = c(NA, "end_col")
  # )

  ## end_row and end_col are specified --> lower right cell is fully specified
  #  1 start_row start_col end_row end_col
  #  5 start_row NA        end_row end_col
  #  9 NA        start_col end_row end_col
  # 13 NA        NA        end_row end_col
  if (noNA(limits$lr)) return(cellranger::as.range(x, fo = "A1"))

  ## start of special handling,
  ## cellranger::as.range() returns NA for everything below here, but that's
  ## not what I want

  ## nothing is specified
  # 16 NA        NA        NA      NA
  if (allNA(unlist(limits))) return(NULL)

  row_limits <- map_int(limits, 1)
  col_limits <- map_int(limits, 2)

  ## no cols specified, but end_row is
  #  6 start_row NA        end_row NA
  # 14 NA        NA        end_row NA
  if (allNA(col_limits) && notNA(row_limits[2])) {
    return(paste0(row_limits, collapse = ":"))
  }
  ## no rows specified, but end_col is
  # 11 NA        start_col NA      end_col
  # 15 NA        NA        NA      end_col
  if (allNA(row_limits) && noNA(col_limits)) {
    return(paste0(cellranger::num_to_letter(col_limits), collapse = ":"))
  }

  # in all remaining scenarios, you can't produce a valid Sheets A1 reference
  # without replacing one or more NAs with something specific
  #
  # these should all be eliminated via pre-processing with resolve_limits()
  #
  # shared property of what's left:
  # let X be in {row, column}
  # start_X is specified, but end_X is NA
  #
  #  2 start_row start_col end_row NA
  # 10 NA        start_col end_row NA
  #  3 start_row start_col NA      end_col
  #  7 start_row NA        NA      end_col
  #  4 start_row start_col NA      NA
  #  8 start_row NA        NA      NA
  # 12 NA        start_col NA      NA
  stop_glue("Can't express the specified {bt('range')} as an A1 reference")
}

# think of cell_limits like so:
#    start_row          end_row
#    start_col          end_col
# if ^ is not NA, then ^ must not be NA either
#
# here we replace end_row or end_col in such cases with an actual number
#
# if provided, sheet_data is a list with two named elements:
#   * `grid_rows` = max row extent
#   * `grid_columns` = max col extent
# probably obtained like so:
# df â‰¤- sheets_get()$sheets
# df[df$name == sheet, c("grid_rows", "grid_columns")]
resolve_limits <- function(cell_limits, sheet_data = NULL) {
  # If no sheet_data, use theoretical maxima.
  # Rows: Max number of cells is 5 million. So that must be the maximum
  #       number of rows (imagine a spreadsheet with 1 sheet and 1 column).
  # Columns: Max col is 'ZZZ' = 18278
  MAX_ROW <- 5000000
  MAX_COL <- 18278

  row_limits <- map_int(cell_limits[c("ul", "lr")], 1)
  col_limits <- map_int(cell_limits[c("ul", "lr")], 2)

  if (identical(is.na(row_limits), c(ul = FALSE, lr = TRUE))) {
    cell_limits$lr[1] <- as.integer(sheet_data$grid_rows %||% MAX_ROW)
  }
  if (identical(is.na(col_limits), c(ul = FALSE, lr = TRUE))) {
    cell_limits$lr[2] <- as.integer(sheet_data$grid_columns %||% MAX_COL)
  }
  cell_limits
}

## Note: this function is NOT vectorized, x is scalar
as_cell_limits <- function(x) {
  check_character(x)
  check_length_one(x)
  ## match against <sheet name>!<A1 cell reference or range>?
  parsed <- rematch2::re_match(x, compound_rx)

  ## successful match (and parse)
  if (notNA(parsed$`.match`)) {
    cell_limits <- limits_from_range(parsed$range)
    cell_limits$sheet <- parsed$sheet
    return(cell_limits)
  }

  ## failed to match
  ## two possibilities:
  ##   * An A1 cell reference or range
  ##   * Name of a sheet or named region
  if (all(grepl(A1_rx, strsplit(x, split = ":")[[1]]))) {
    limits_from_range(x)
  } else {
    ## TO THINK: I am questioning if this should even be allowed
    ## perhaps you MUST use sheet argument for this, not range?
    ## to be clear: we're talking about passing a sheet name or name of a
    ## named range, without a '!A1:C4' type of range as suffix
    cell_limits(sheet = x)
  }
  ## TODO: above is still not sophisticated enough to detect that
  ## A, AA, AAA (strings of length less than 4) and
  ## 1, 12, ..., 1234567 (numbers with less than 8 digits)
  ## are not, I believe, valid ranges
}

limits_from_range <- function(x) {
  x_split <- strsplit(x, ":")[[1]]
  if (!length(x_split) %in% 1:2)   {stop_glue("Invalid range: {sq(x)}")}
  if (!all(grepl(A1_rx, x_split))) {stop_glue("Invalid range: {sq(x)}")}
  corners <- rematch2::re_match(x_split, A1_decomp)
  if (any(is.na(corners$.match)))  {stop_glue("Invalid range: {sq(x)}")}
  corners$column <- ifelse(nzchar(corners$column), corners$column, NA_character_)
  corners$row <- ifelse(nzchar(corners$row), corners$row, NA_character_)
  if (nrow(corners) == 1) {
    corners <- corners[c(1, 1), ]
  }
  cellranger::cell_limits(
    ul = c(
      corners$row[1] %NA% NA_integer_,
      cellranger::letter_to_num(corners$column[1]) %NA% NA_integer_
    ),
    lr = c(
      corners$row[2] %NA% NA_integer_,
      cellranger::letter_to_num(corners$column[2]) %NA% NA_integer_
    )
  )
}

check_range <- function(range = NULL) {
  if (is.null(range) ||
      inherits(range, what = "cell_limits") ||
      is_string(range)) return(range)
  stop_glue(
    "{bt('range')} must be NULL, a string, or a {bt('cell_limits')} object."
  )
}

## the `...` are used to absorb extra variables when this is used inside pmap()
make_range <- function(start_row, end_row, start_column, end_column,
                       sheet_name, ...) {
  cl <- cellranger::cell_limits(
    ul = c(start_row, start_column),
    lr = c(end_row, end_column),
    sheet = sq(sheet_name)
  )
  cellranger::as.range(cl, fo = "A1")
}

## A pair of functions for the (un)escaping of spreadsheet names
## for use in range strings like 'Sheet1'!A2:D4
sq_escape <- function(x) {
  ## if string already starts and ends with single quote, pass it through
  is_not_quoted <- !map_lgl(x, ~ grepl("^'.*'$", .x))
  ## duplicate each single quote and protect string with single quotes
  x[is_not_quoted] <- paste0("'", gsub("'", "''", x[is_not_quoted]), "'")
  x
}

sq_unescape <- function(x) {
  ## only modify if string starts and ends with single quote
  is_quoted <- map_lgl(x, ~ grepl("^'.*'$", .x))
  ## strip leading and trailing single quote and substitute 1 single quote
  ## for every pair of single quotes
  x[is_quoted] <- gsub("''", "'", sub("^'(.*)'$", "\\1", x[is_quoted]))
  x
}
